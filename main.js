/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HarvestPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  personalAccessToken: "",
  accountId: "",
  pollingInterval: 5
  // Default to 5 minutes
};
var HarvestPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.runningTimer = null;
    this.projectCache = [];
  }
  // Cache for the combined project list
  async onload() {
    await this.loadSettings();
    this.statusBarItemEl = this.addStatusBarItem();
    this.statusBarItemEl.setText("Harvest");
    this.addSettingTab(new HarvestSettingTab(this.app, this));
    this.fetchAllTrackableProjects();
    this.addCommand({
      id: "start-harvest-timer",
      name: "Start Harvest Timer",
      callback: () => {
        new ProjectSuggestModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "stop-harvest-timer",
      name: "Stop Harvest Timer",
      callback: async () => {
        if (this.runningTimer) {
          await this.stopTimer(this.runningTimer.id);
        } else {
          new import_obsidian.Notice("No timer is currently running.");
        }
      }
    });
    this.addCommand({
      id: "refresh-harvest-projects",
      name: "Refresh Harvest Projects",
      callback: async () => {
        new import_obsidian.Notice("Refreshing project list from Harvest...");
        await this.fetchAllTrackableProjects(true);
        new import_obsidian.Notice("Harvest project list has been updated.");
      }
    });
    const pollingMinutes = this.settings.pollingInterval > 0 ? this.settings.pollingInterval : 5;
    this.timerInterval = window.setInterval(() => this.updateRunningTimer(), pollingMinutes * 60 * 1e3);
    this.updateRunningTimer();
  }
  onunload() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async request(endpoint, method = "GET", body = null) {
    if (!this.settings.personalAccessToken || !this.settings.accountId) {
      new import_obsidian.Notice("Harvest API credentials are not set.");
      return null;
    }
    const headers = {
      "Authorization": `Bearer ${this.settings.personalAccessToken}`,
      "Harvest-Account-Id": this.settings.accountId,
      "User-Agent": "Obsidian Harvest Integration",
      "Content-Type": "application/json"
    };
    try {
      const response = await fetch(`https://api.harvestapp.com/v2${endpoint}`, {
        method,
        headers,
        body: body ? JSON.stringify(body) : null
      });
      if (!response.ok) {
        const errorData = await response.json();
        new import_obsidian.Notice(`Harvest API Error: ${errorData.message || response.statusText}`);
        return null;
      }
      return response.json();
    } catch (error) {
      new import_obsidian.Notice("Failed to connect to Harvest API.");
      console.error("Harvest API request error:", error);
      return null;
    }
  }
  async fetchAllTrackableProjects(forceRefresh = false) {
    if (this.projectCache.length > 0 && !forceRefresh) {
      return this.projectCache;
    }
    const managedProjects = await this.getManagedProjects();
    const recentProjects = await this.getRecentProjectsFromTimeEntries();
    const combinedProjectMap = /* @__PURE__ */ new Map();
    managedProjects.forEach((proj) => combinedProjectMap.set(proj.id, proj));
    recentProjects.forEach((proj) => {
      if (!combinedProjectMap.has(proj.id)) {
        combinedProjectMap.set(proj.id, proj);
      }
    });
    const sortedProjects = Array.from(combinedProjectMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    this.projectCache = sortedProjects;
    return this.projectCache;
  }
  async getManagedProjects() {
    let allProjects = [];
    let page = 1;
    let totalPages = 1;
    do {
      const data = await this.request(`/projects?is_active=true&page=${page}`);
      if (data && data.projects) {
        allProjects = allProjects.concat(data.projects);
        totalPages = data.total_pages;
        page++;
      } else {
        break;
      }
    } while (page <= totalPages);
    return allProjects;
  }
  async getRecentProjectsFromTimeEntries() {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const fromDate = thirtyDaysAgo.toISOString().split("T")[0];
    const data = await this.request(`/time_entries?from=${fromDate}`);
    if (!data || !data.time_entries)
      return [];
    const recentProjectsMap = /* @__PURE__ */ new Map();
    data.time_entries.forEach((entry) => {
      if (entry.project && !recentProjectsMap.has(entry.project.id)) {
        recentProjectsMap.set(entry.project.id, entry.project);
      }
    });
    return Array.from(recentProjectsMap.values());
  }
  async startTimer(projectId, taskId) {
    const body = {
      project_id: projectId,
      task_id: taskId,
      spent_date: new Date().toISOString().slice(0, 10)
    };
    const result = await this.request("/time_entries", "POST", body);
    if (result) {
      new import_obsidian.Notice("Harvest timer started!");
      this.updateRunningTimer();
    }
  }
  async updateRunningTimer() {
    const data = await this.request("/time_entries?is_running=true");
    if (data && data.time_entries && data.time_entries.length > 0) {
      this.runningTimer = data.time_entries[0];
      const { project, task, hours } = this.runningTimer;
      this.statusBarItemEl.setText(`Harvest: ${project.name} - ${task.name} (${hours.toFixed(2)}h)`);
    } else {
      this.runningTimer = null;
      this.statusBarItemEl.setText("Harvest: No timer running");
    }
  }
  async stopTimer(timerId) {
    const result = await this.request(`/time_entries/${timerId}/stop`, "PATCH");
    if (result) {
      new import_obsidian.Notice("Harvest timer stopped.");
      this.updateRunningTimer();
    }
  }
};
var ProjectSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  getItems() {
    return this.plugin.projectCache;
  }
  getItemText(project) {
    return project.name;
  }
  renderSuggestion(match, el) {
    var _a;
    const project = match.item;
    el.createEl("div", { text: project.name });
    el.createEl("small", { text: ((_a = project.client) == null ? void 0 : _a.name) || "No Client" });
  }
  async onChooseItem(project) {
    let tasks = project.task_assignments;
    if (!tasks) {
      const data = await this.plugin.request(`/projects/${project.id}/task_assignments`);
      tasks = data == null ? void 0 : data.task_assignments;
    }
    if (tasks && tasks.length > 0) {
      new TaskSuggestModal(this.app, this.plugin, project, tasks).open();
    } else {
      new import_obsidian.Notice("No tasks found for this project.");
    }
  }
};
var TaskSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, plugin, project, tasks) {
    super(app);
    this.plugin = plugin;
    this.project = project;
    this.tasks = tasks;
  }
  getItems() {
    return this.tasks;
  }
  getItemText(taskAssignment) {
    return taskAssignment.task.name;
  }
  renderSuggestion(match, el) {
    el.createEl("div", { text: match.item.task.name });
  }
  onChooseItem(taskAssignment) {
    this.plugin.startTimer(this.project.id, taskAssignment.task.id);
  }
};
var HarvestSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Harvest Integration Settings" });
    new import_obsidian.Setting(containerEl).setName("Personal Access Token").setDesc("Get this from the Developers section of your Harvest ID.").addText((text) => text.setPlaceholder("Enter your token").setValue(this.plugin.settings.personalAccessToken).onChange(async (value) => {
      this.plugin.settings.personalAccessToken = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Account ID").setDesc("You can also find this on the same page as your token.").addText((text) => text.setPlaceholder("Enter your Account ID").setValue(this.plugin.settings.accountId).onChange(async (value) => {
      this.plugin.settings.accountId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Polling Interval").setDesc("How often to check for a running timer, in minutes. Requires a reload to take effect.").addText((text) => text.setPlaceholder("Default: 5").setValue(String(this.plugin.settings.pollingInterval)).onChange(async (value) => {
      const interval = parseInt(value);
      if (!isNaN(interval) && interval > 0) {
        this.plugin.settings.pollingInterval = interval;
        await this.plugin.saveSettings();
      }
    }));
  }
};
